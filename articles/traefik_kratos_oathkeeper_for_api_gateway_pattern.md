---  
title: traefik proxy + kratos + oathkeeper によるAPIゲートウェイパターン構築
emoji: "📦" 
type: "tech" 
topics: ["aws", "traefik", "kratos", "oathkeeper", "container"] 
published: false
---  
## 概要
以下のOSSを使用した、コンテナベースのAPIゲートウェイパターンのインフラを構築しました。

|  OSS  |  役割  |
| ---- | ---- |
|  Traefik proxy  |  APIゲートウェイ、リバースプロキシ  |
|  Kratos  |  認証API、Identity Provider  |
|  Oathkeeper  |  認証ミドルウェア  |

下図に構成概要を示します。

上記OSS以外に、フロントエンド(SPA)のコンテナ、APIのコンテナ、DBが存在します。

[infra-overview]

インターネットからリクエストをTraefik proxy(以降Traefik)が受け付けます。

Traefikには、受け付けたリクエストのホスト名やパス等の条件でルーティングルールを設定しており、APIサーバー等へロードバランシングやリダイレクトのルールを記述可能です。

TraefikがAPIゲートウェイとしての役割を果たし、ルーティングルールに従って、後段のサーバーへリクエストを流します。

Kratosは、ユーザーの認証情報(Identity)を管理するIdentityProviderとしての機能と、ユーザーからアクセス可能な認証API（サインイン・ログインなど）を提供します。

専用DBにIdentityを管理することもできますし、Google等の外部IdentityProviderとOAuthで接続し、ログインセッション等はKratos側で管理する等の連携が可能です。

OathKeeperは、Traefikと連携し、リクエストのセッションが認証されているかどうかを検査し、認証されている場合は、認証情報をバックエンドが理解できる形(ここではIDToken)へ変換し、Traefikへ戻し、改めてルーティングされます。
（上図ではService AのAPIへルーティングしています。）




方針として、
* ポータビリティを確保する
  - 同様の構成で別のプロダクトをインフラ構築を効率化する
  - マネージメントサービスに依存しすぎず、OSSのようなコード・実装の詳細がオープンにされているものを使用する
  - インフラを可能な限りコード化する
* マイクロサービスの下地を作っておく
  - 認証APIの独立させて、ロジックから切り離す（特定のAPIやFWに依存しない）
  
* ローカル開発環境も同様に



将来的に他のパブリッククラウドに移行できることを見据えた設計にもしたい）

特定のサービスに依存しないことで、アーキテクチャの変更や





AWSにて、Traefik proxy + Kratos + Oathkeeperを使用したKubernetesベースのインフラを構築しました。

Traefik proxyはリバースプロキシ、Kratosは認証API、Oathkeeperは認証ミドルウェアとして使用しています。

複数のUI、APIを持つプロジェクトに対して、認証機能のアプリケーションからの切り離しや、高機能なリバースプロキシによる柔軟なアクセス制御が有効であり、アプリケーション側の複雑度を低減可能な構成です。

構成の詳細を設計思想も交えて紹介します。


## 背景

### APIに認証機能を含める場合の課題

アプリケーションフレームワークには、認証機能を含んでいるものが多くあります。

例えば、LaravelやNestJSなどがそうです。

非常に便利な機能であり、フレームワークに習熟していれば素早く認証機能を構築可能で、単一のアプリケーションを構築、運用していく場合には効率的です。

ここで、構築したものとはまた別にAPIを構築したい事情が出てきたとしましょう。

考えられる状況として、別の言語で得意な領域があり、それを活かしたAPIを構築したいという場合が考えられます。

このような状況の例として、NestJSで構築していたAPIがあり、それとは別にPython製のベクトル計算や学習を行うAPIを構築したい、という場合を考えてみます。

anothoer-api-example-1

NestJSには認証情報として、ログインセッションを受け取ることとし、実装方法としてJWTやCookieがありますが、ここではCookieを想定します。

取り扱う領域が異なったり、既存とは異なる種類のDBを選択したいということも大いに考えられるため、Python製のAPIからは別のDBを使用することとし、こちらには学習した結果や計算結果のベクトル値等を格納する想定とします。

このケースでは、認証機能はNestJS内にあるため、リクエストを一度NestJSを経由して、認証されたリクエストのみをPythonAPIへ転送する必要があります。

NestJSがプロキシの役割を担うことになります。

必ずNestJSを経由する必要があるため、NestJSに負荷がかかり、またプロキシのためのコードの追加も必要です。

PythonAPIの数が多くなってくると、コードの肥大化・複雑化し、意外とコストになってきます。


もうひとつのパターンとして、NestJSの認証系APIをPythonAPIから呼び出すことも。可能だと思います。

anothoer-api-example-2

このパターンでは、NestJSでプロキシしないため、前述のコード追加に関するデメリットは回避できるため、こちらの方が良さそうです。

他にもいくつかAPIサーバが増えたり、アクセス数の高いものがでてきたら、認証必要な全てのリクエストがNestJSへ認証を問い合わせるため、やはり負荷はNestJSに集中します。

負荷がNestJSのコアロジック部分に影響したり、その逆も考えられます。

この問題も解決したいと考えると、認証APIのみを別サーバに切り出して、コアロジックとは分離する必要があります。

### mTLSによるアクセス制限したい

スタッフのみが使用する管理画面やDevOpsツール画面は、ID/PWの認証のほかにVPNやMFAなど、多重に対策してセキュリティレベルを高めておきたいものです。

その対策の一つとして、mTLS(mutual TLS)があります。

ざっくり説明すると、通常はサーバ側にのみTLS証明書を持ち、それが信頼できる場合にサーバ側の証明書を使用して暗号通信をおこないますが、mTLSではこれに加えて、クライアント側にも証明書を持ち、サーバ側がクライアント証明書を検証するというフェーズが追加されます。

もう少し詳細には、[この辺](https://www.cloudflare.com/ja-jp/learning/access-management/what-is-mutual-tls/)の記事がわかりやすいです。

ネットワークによらず、より強固なアクセス制限が可能なため、限られたスタッフのみがアクセスするUIやAPIが保護できて、安心感が増します。

（勿論、VPN等も併用するのが望ましいですが）

mTLSを実現するためには、サーバ側にmTLS機能を持つ必要があります。

AWSでは、[API Gatewayが対応している](https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/http-api-mutual-tls.html)ようです。

しかしながら、ALBでは対応されておらず、API Gatewayを組み合わせるか、別途mTLSに対応したサーバを設置する必要があります。

## 全体

上述の課題を解決するアーキテクチャを考えると、以下のような要件になりそうです。

* 認証専用のAPIを、コアロジックのAPIとは別に設置する
* mTLS機能を持つAPI Gatewayを設置する (AWSのサービス名ではなく、アーキテクチャ用語としてのAPI Gatewayです)
* 

全体構成

Kratosは、ユーザーの認証に関する機能を提供するIdentity Provider

Traefik proxyは、リバースプロキシの役割を担い、







## まとめ
Traefik proxy + Kratos + Oathkeeperを使用したコンテナベースのインフラ構成の紹介と、そのメリットについて解説しました。

本格的にマイクロサービスを構築するためには、まだまだ考慮するべき点があるとは思いますが、その基礎として、本構成はかなり刺さるかと思います。

複数APIを持つ場合はもちろんですが、現時点で単一のAPIしか持たない場合にも、将来的にマイクロサービスへの移行の下地を作っておく意味で、有効な構成と考えています。
